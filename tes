local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local Net = require(ReplicatedStorage.Packages.Net)
local RaycastUtility = require(ReplicatedStorage.Shared.RaycastUtility)
local Constants = require(ReplicatedStorage.Shared.Constants)
local BlockedHumanoidStates = require(ReplicatedStorage.Shared.BlockedHumanoidStates)
local Replion = require(ReplicatedStorage.Packages.Replion)
local PlayerStatsUtility = require(ReplicatedStorage.Shared.PlayerStatsUtility)
local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)

local chargeRemote = Net:RemoteFunction("ChargeFishingRod")
local startRemote = Net:RemoteFunction("RequestFishingMinigameStarted")
local completeRemote = Net:RemoteEvent("FishingCompleted")
local fishCaughtRemote = Net:RemoteEvent("FishCaught")

local AutoFishing = {}
AutoFishing.Settings = {
    ChargeDelay = 0.15,
    Power = 1,
    FailDelay = 0.75,
    SuccessDelay = Constants.FishingCooldownTime + 0.2,
    DefaultCompleteDelay = 1.2,
    CompleteRetryDelay = 0.35,
    CompleteCheckStep = 0.05,
    MinCompleteDelay = 0.25,
    MaxCompleteDelay = 1.8,
    WindupDelayScale = 0.3,
}

AutoFishing._running = false
AutoFishing._thread = nil
AutoFishing._lastCatch = 0
AutoFishing._data = nil
AutoFishing._rodInfo = nil
AutoFishing._chargeStart = 0
AutoFishing._waitingForCatch = false
AutoFishing._lastCatchInfo = nil

AutoFishing.RodDelays = {
    ["Starter Rod"] = 1.35,
    ["Advanced Rod"] = 1.05,
    ["Pro Rod"] = 0.9,
}

local function getCharacter()
    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

local function buildRaycastParams()
    local params = RaycastParams.new()
    params.IgnoreWater = true
    params.RespectCanCollide = false
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = RaycastUtility:getFilteredTargets(LocalPlayer)
    return params
end

function AutoFishing:_getData()
    if self._data and not self._data.Destroyed then
        return self._data
    end
    local ok, data = pcall(function()
        return Replion.Client:WaitReplion("Data")
    end)
    if ok then
        self._data = data
        return data
    end
end

function AutoFishing:_resolveEquippedRod(data)
    data = data or self:_getData()
    if not data then
        self._rodInfo = nil
        return
    end
    local equippedId = data:GetExpect("EquippedId")
    if type(equippedId) ~= "string" or equippedId == "" then
        self._rodInfo = nil
        return
    end
    if self._rodInfo and self._rodInfo.uuid == equippedId then
        return self._rodInfo.data
    end
    local ok, item, container = pcall(function()
        return PlayerStatsUtility:GetItemFromInventory(data, function(entry)
            return entry.UUID == equippedId
        end)
    end)
    if not ok then
        warn("[AutoFishing] Failed to read inventory:", item)
        self._rodInfo = nil
        return
    end
    if not item then
        self._rodInfo = nil
        return
    end
    local category = "Items"
    if container and container.Category then
        category = container.Category
    end
    local itemData = ItemUtility.GetItemDataFromItemType(category, item.Id)
    if not itemData or itemData.Data.Type ~= "Fishing Rods" then
        self._rodInfo = nil
        return
    end
    self._rodInfo = {
        uuid = equippedId,
        data = itemData,
    }
    return itemData
end

function AutoFishing:_hasUnlockedPath(pathName)
    if not pathName then
        return true
    end
    local data = self:_getData()
    if not data then
        return false
    end
    local ok, value = pcall(function()
        return data:Get(pathName)
    end)
    if not ok then
        return false
    end
    return value == true
end

function AutoFishing:_characterCanFish()
    local character = LocalPlayer.Character
    if not character then
        return false, "Character not ready"
    end
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then
        return false, "Missing humanoid"
    end
    if table.find(BlockedHumanoidStates.Fishing, humanoid:GetState()) then
        return false, "Humanoid state blocked"
    end
    if humanoid.FloorMaterial == Enum.Material.Water then
        return false, "Standing in water"
    end
    if humanoid.SeatPart then
        return false, "Sitting"
    end
    if LocalPlayer:GetAttribute("Loading") then
        return false, "Player still loading"
    end
    local data = self:_getData()
    if not data then
        return false, "Player data unavailable"
    end
    if Constants.MaxInventorySize <= Constants:CountInventorySize(data) then
        return false, "Inventory full"
    end
    if not self:_resolveEquippedRod(data) then
        return false, "No fishing rod equipped"
    end
    local elapsed = workspace:GetServerTimeNow() - self._lastCatch
    if elapsed < Constants.FishingCooldownTime then
        return false, "Fishing cooldown"
    end
    return true
end

function AutoFishing:_chargeRod()
    local now = workspace:GetServerTimeNow()
    local ok, accepted, serverTime = pcall(function()
        return chargeRemote:InvokeServer(nil, nil, nil, now)
    end)
    if not ok then
        return false, accepted
    end
    if not accepted then
        return false, serverTime or "Charge rejected"
    end
    if typeof(serverTime) == "number" then
        self._chargeStart = serverTime
    else
        self._chargeStart = now
    end
    return true
end

function AutoFishing:_raycast(power)
    local character = getCharacter()
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then
        return nil, "Missing HumanoidRootPart"
    end
    local origin = root.CFrame.Position + root.CFrame.LookVector * (power * 15 + 10)
    local result = workspace:Raycast(origin, Vector3.new(0, -Constants.FishingDistance, 0), buildRaycastParams())
    if not result or not result.Instance then
        return nil, "No valid fishing spot"
    end
    local zone = result.Instance:GetAttribute("EligiblePath")
    if zone and not self:_hasUnlockedPath(zone) then
        return nil, "Zone is locked"
    end
    return result
end

function AutoFishing:_castOnce()
    local canFish, reason = self:_characterCanFish()
    if not canFish then
        return false, reason
    end

    local charged, chargeErr = self:_chargeRod()
    if not charged then
        return false, chargeErr or "Failed to charge"
    end

    task.wait(self.Settings.ChargeDelay)

    local rayResult, rayError = self:_raycast(self.Settings.Power)
    if not rayResult then
        return false, rayError
    end

    local timestamp = self._chargeStart or workspace:GetServerTimeNow()
    local ok, started, response = pcall(function()
        return startRemote:InvokeServer(rayResult.Position.Y, self.Settings.Power, timestamp)
    end)
    if not ok then
        return false, started
    end
    if not started then
        return false, response or "Server rejected fishing request"
    end

    local caught, catchErr = self:_completeCatch()
    if not caught then
        return false, catchErr
    end
    return true
end

function AutoFishing:_loop()
    while self._running do
        local success, err = self:_castOnce()
        if not success then
            warn("[AutoFishing]", err)
            task.wait(self.Settings.FailDelay)
        else
            task.wait(self.Settings.SuccessDelay)
        end
    end
end

function AutoFishing:Start()
    if self._running then
        return
    end
    self._running = true
    self._thread = task.spawn(function()
        while not LocalPlayer.Character do
            LocalPlayer.CharacterAdded:Wait()
        end
        self:_loop()
    end)
end

function AutoFishing:Stop()
    if not self._running then
        return
    end
    self._running = false
    self._waitingForCatch = false
    if self._thread then
        task.cancel(self._thread)
        self._thread = nil
    end
end

function AutoFishing:Toggle(state)
    if state == nil then
        state = not self._running
    end
    if state then
        self:Start()
    else
        self:Stop()
    end
end

function AutoFishing:_getCompletionDelay()
    local rod = self._rodInfo and self._rodInfo.data
    if rod then
        local data = rod.Data or {}
        if type(data.AutoCatchDelay) == "number" then
            return data.AutoCatchDelay
        end
        local rodName = data.Name
        if rodName then
            local configured = self.RodDelays[rodName]
            if type(configured) == "number" then
                return configured
            end
        end
        local windup = rod.Windup or data.Windup
        if typeof(windup) == "NumberRange" then
            local avg = (windup.Min + windup.Max) / 2
            local scaled = avg * (self.Settings.WindupDelayScale or 0.3)
            local minDelay = self.Settings.MinCompleteDelay or 0
            local maxDelay = self.Settings.MaxCompleteDelay or scaled
            return math.clamp(scaled, minDelay, maxDelay)
        end
    end
    return self.Settings.DefaultCompleteDelay
end

function AutoFishing:_completeCatch()
    local delay = self:_getCompletionDelay()
    if delay > 0 then
        task.wait(delay)
    end
    self._waitingForCatch = true
    completeRemote:FireServer()
    local waited = 0
    while waited < self.Settings.CompleteRetryDelay do
        if not self._waitingForCatch then
            return true
        end
        local step = math.min(self.Settings.CompleteCheckStep, self.Settings.CompleteRetryDelay - waited)
        task.wait(step)
        waited += step
    end
    self._waitingForCatch = false
    return false, "Fish completion timed out"
end

local function resolveFishNameAndWeight(itemId, catchInfo)
    local fishName = "Unknown fish"
    local ok, itemData = pcall(function()
        return ItemUtility:GetItemData(itemId)
    end)
    if ok and itemData and itemData.Data and itemData.Data.Name then
        fishName = itemData.Data.Name
    end

    local weightText = "?"
    if type(catchInfo) == "table" then
        if catchInfo.WeightText then
            weightText = catchInfo.WeightText
        elseif catchInfo.Weight then
            local decimal = tonumber(catchInfo.Weight)
            if decimal then
                weightText = string.format("%.2f", decimal)
            end
        elseif catchInfo.WeightValue then
            local decimal = tonumber(catchInfo.WeightValue)
            if decimal then
                weightText = string.format("%.2f", decimal)
            end
        end
    elseif type(catchInfo) == "number" then
        weightText = string.format("%.2f", catchInfo)
    elseif type(catchInfo) == "string" and catchInfo ~= "" then
        weightText = catchInfo
    end

    return fishName, weightText
end

local function initRayfield()
    local ok, Rayfield = pcall(function()
        return loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
    end)
    if not ok or not Rayfield then
        warn("[AutoFishing] Failed to load Rayfield:", Rayfield)
        return
    end

    local Window = Rayfield:CreateWindow({
        Name = "FishIt",
        LoadingTitle = "Auto Fisher",
        LoadingSubtitle = "by Codex",
        DisableRayfieldPrompts = true,
        ConfigurationSaving = {
            Enabled = true,
            FolderName = "FishItConfigs",
            FileName = "AutoFishing",
        },
    })

    local Tab = Window:CreateTab("Fishing", 4483362458)
    Tab:CreateParagraph({
        Title = "Auto Catch",
        Content = "Toggle below to auto cast instantly. Minigame is skipped.",
    })

    local toggle = Tab:CreateToggle({
        Name = "Auto Fishing",
        CurrentValue = false,
        Flag = "FishIt_AutoFishing_Toggle",
        Callback = function(value)
            AutoFishing:Toggle(value)
        end,
    })
    local sliderConfigs = {
        {
            Name = "Charge Delay",
            Range = {0, 1},
            Increment = 0.01,
            Suffix = " s",
            Flag = "FishIt_ChargeDelay",
            SettingKey = "ChargeDelay",
        },
        {
            Name = "Cast Power",
            Range = {0.1, 1},
            Increment = 0.01,
            Suffix = " power",
            Flag = "FishIt_Power",
            SettingKey = "Power",
        },
        {
            Name = "Default Catch Delay",
            Range = {0.2, 2},
            Increment = 0.01,
            Suffix = " s",
            Flag = "FishIt_DefaultCompleteDelay",
            SettingKey = "DefaultCompleteDelay",
        },
        {
            Name = "Windup Delay Scale",
            Range = {0.1, 0.7},
            Increment = 0.01,
            Suffix = "x",
            Flag = "FishIt_WindupScale",
            SettingKey = "WindupDelayScale",
        },
        {
            Name = "Completion Confirm Wait",
            Range = {0.1, 1},
            Increment = 0.01,
            Suffix = " s",
            Flag = "FishIt_CompleteRetryDelay",
            SettingKey = "CompleteRetryDelay",
        },
    }
    local sliderRegistry = {}
    for _, config in ipairs(sliderConfigs) do
        AutoFishing.Settings[config.SettingKey] = math.clamp(
            AutoFishing.Settings[config.SettingKey],
            config.Range[1],
            config.Range[2]
        )
        local slider = Tab:CreateSlider({
            Name = config.Name,
            Range = config.Range,
            Increment = config.Increment,
            Suffix = config.Suffix,
            CurrentValue = AutoFishing.Settings[config.SettingKey],
            Flag = config.Flag,
            Callback = function(value)
                AutoFishing.Settings[config.SettingKey] = value
            end,
        })
        sliderRegistry[config.Flag] = {
            Slider = slider,
            Config = config,
        }
    end

    Rayfield:LoadConfiguration()
    task.defer(function()
        local flags = Rayfield.Flags
        if not flags then
            return
        end
        local saved = flags["FishIt_AutoFishing_Toggle"]
        if saved and typeof(saved.CurrentValue) == "boolean" then
            toggle:Set(saved.CurrentValue)
        end
        for flagName, pack in pairs(sliderRegistry) do
            local savedSlider = flags[flagName]
            if savedSlider and typeof(savedSlider.CurrentValue) == "number" then
                local min = pack.Config.Range[1]
                local max = pack.Config.Range[2]
                local value = math.clamp(savedSlider.CurrentValue, min, max)
                AutoFishing.Settings[pack.Config.SettingKey] = value
                pack.Slider:Set(value)
            end
        end
    end)
end

fishCaughtRemote.OnClientEvent:Connect(function(...)
    AutoFishing._waitingForCatch = false
    AutoFishing._lastCatch = workspace:GetServerTimeNow()
    local args = table.pack(...)
    AutoFishing._lastCatchInfo = args
    local itemId = args[2]
    local catchDetails = args[3]
    local fishName, weightText = resolveFishNameAndWeight(itemId, catchDetails)
    print(string.format("[AutoFishing] Caught %s (%s)", fishName, weightText))
end)

task.spawn(initRayfield)

LocalPlayer.CharacterAdded:Connect(function()
    AutoFishing._lastCatch = 0
end)

return AutoFishing
